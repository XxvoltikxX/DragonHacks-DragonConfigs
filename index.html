<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DragonConfigs - Home</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;500;700&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="Style.css" /> {/* Jeśli plik Style.css istnieje i zawiera dodatkowe style, upewnij się, że ścieżka jest poprawna */}

  <style>
    /* ============================
        Reset i podstawowa struktura
        ============================ */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html, body {
      width: 100%;
      height: 100%;
      overflow-x: hidden;
      font-family: 'Poppins', sans-serif;
      background-color: #000; /* w razie problemu z wideo */
    }

    /* ============================
        Pasek nawigacyjny – półprzezroczysty
        ============================ */
    nav {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 60px;
      line-height: 60px;
      background-color: rgba(0, 0, 0, 0.8);
      border-bottom: 1px solid rgba(34, 34, 34, 0.8);
      display: flex;
      align-items: center;
      padding: 0 1rem;
      z-index: 10;
    }
    /* Animowany napis „DragonConfigs” */
    .nav-logo {
      font-size: 1.5rem;
      font-weight: 700;
      background: linear-gradient(
        45deg,
        #00ffd1 0%,
        #00bfff 25%,
        #ff00ff 50%,
        #ff0055 75%,
        #ffee00 100%
      );
      background-size: 200% 200%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: gradient-wave 1.5s ease-in-out infinite;
      text-decoration: none;
      margin-right: 2rem;
    }
    @keyframes gradient-wave {
      0%   { background-position: 0% 50%; }
      50%  { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    .nav-list {
      display: flex;
      list-style: none;
      gap: 1.5rem;
    }
    .nav-list li {
      position: relative;
    }
    .nav-list a {
      color: #e0e0e0;
      text-decoration: none;
      font-size: 1rem;
      transition: color 0.2s ease;
    }
    .nav-list a:hover,
    .nav-list .active > a {
      color: #00ffc2;
    }
    /* Dropdown */
    .dropdown-menu {
      display: none;
      position: absolute;
      top: 100%;
      left: 0;
      background-color: rgba(0, 0, 0, 0.8);
      border: 1px solid rgba(34, 34, 34, 0.8);
      border-radius: 4px;
      list-style: none;
      padding: 0.5rem 0;
      z-index: 11;
    }
    .dropdown:hover .dropdown-menu {
      display: block;
    }
    .dropdown-menu li {
      margin: 0;
    }
    .dropdown-menu a {
      display: block;
      padding: 0.4rem 1rem;
      white-space: nowrap;
      color: #e0e0e0;
    }
    .dropdown-menu a:hover {
      background-color: rgba(34, 34, 34, 0.8);
      color: #00ffc2;
    }

    /* ============================
        Canvas z unoszącymi się pyłkami
        ============================ */
    #fireCanvas {
      position: fixed;
      top: 60px;
      left: 0;
      width: 100vw;
      height: calc(100vh - 60px);
      pointer-events: none;
      z-index: 2;
    }

    /* ============================
        Kontener iframe (tło wideo) z rozmyciem
        ============================ */
    .video-background {
      position: fixed;
      top: 60px; /* Dopasowane do wysokości paska nawigacyjnego */
      left: 0;
      width: 100vw;
      height: calc(100vh - 60px); /* Wypełnia pozostałą część ekranu */
      z-index: 0; /* Pod innymi elementami */
      overflow: hidden; /* Aby ucięte części iframe nie były widoczne */
      pointer-events: none; /* Pozwala na kliknięcia "przez" ten div do overlay'a */
    }
    .video-background iframe {
      position: absolute;
      top: 50%;
      left: 50%;
      /* Proporcje 16:9 dla wideo */
      width: 177.77777778vh; /* 100vh * 16/9 */
      min-width: 100vw;
      height: 56.25vw;    /* 100vw * 9/16 */
      min-height: 100vh;
      transform: translate(-50%, -50%); /* Wyśrodkowanie iframe */
      border: none;
      filter: blur(8px);
    }

    /* Overlay do przechwycenia kliknięcia i odciszenia */
    #click-overlay {
      position: fixed;
      top: 60px; /* Musi pasować do pozycji .video-background */
      left: 0;
      width: 100vw;
      height: calc(100vh - 60px); /* Musi pasować do rozmiaru .video-background */
      z-index: 3; /* Nad wideo, pod treścią (hero) */
      cursor: pointer;
      background-color: rgba(0,0,0,0); /* W pełni przezroczysty */
    }

    /* ============================
        Hero (tekst + przycisk na środku ekranu)
        ============================ */
    header.hero {
      position: absolute;
      top: 60px; /* Pod paskiem nawigacyjnym */
      left: 0;
      width: 100vw;
      height: calc(100vh - 60px); /* Wypełnia pozostałą część ekranu */
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      color: #fff;
      z-index: 5; /* Nad overlay i wideo */
    }
    .typewriter-container {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2.5rem;
      font-weight: 700;
      height: auto; /* Lub określona wysokość, jeśli potrzebujesz */
    }
    #typed-text {
      background: linear-gradient(
        45deg,
        #07c9b9 0%,
        #00bfff 25%,
        #ff00ff 50%,
        #ff0055 75%,
        #ffee00 100%
      );
      background-size: 200% 200%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: gradient-wave 1.5s ease-in-out infinite;
      text-shadow: 2px 2px 10px rgba(0, 0, 0, 0.8);
    }
    #cursor {
      display: inline-block;
      margin-left: 4px;
      font-size: 2.5rem;
      font-weight: 700;
      color: #ffffff;
      animation: blink 0.7s step-start infinite;
    }
    @keyframes blink {
      50% { opacity: 0; }
    }
    header.hero p {
      font-size: 1.5rem;
      margin: 1rem 0 2rem;
      color: #f0f0f0;
      text-shadow: 2px 2px 12px rgba(0, 0, 0, 0.7);
    }
    header.hero .btn {
      display: inline-block;
      padding: 0.85rem 1.75rem;
      background-color: transparent; /* Przycisk przezroczysty */
      border: none; /* Usunięcie domyślnej ramki */
      color: #ffffff;
      text-decoration: none;
      font-size: 1rem;
      font-weight: 500;
      transition: color 0.2s ease, transform 0.2s ease;
      text-shadow: 1px 1px 6px rgba(0, 0, 0, 0.8);
      border-radius: 20px; /* Zaokrąglone rogi */
    }
    header.hero .btn:hover {
      color: #00ffc2;
      transform: translateY(-2px);
    }

    /* ============================
        Stopka
        ============================ */
    footer {
      /* margin-top powinien być ustawiony tak, aby stopka była pod treścią.
         Jeśli treść jest dynamiczna, to może być problematyczne.
         Dla tej konkretnej struktury, gdzie hero zajmuje 100vh - 60px: */
      margin-top: calc(100vh - 60px + 60px); /* Cała wysokość widoku + wysokość nav */
      /* Alternatywnie, jeśli .hero nie jest position:absolute, stopka naturalnie ułoży się pod nim */
      position: relative; /* Aby z-index działał poprawnie, jeśli jest potrzebny */
      padding: 1.5rem 1rem;
      background-color: #111;
      color: #aaa;
      text-align: center;
      font-size: 0.9rem;
      z-index: 6; /* Na wierzchu, jeśli inne elementy mogłyby ją zakryć */
    }
    footer a {
      color: #00ffc2;
      text-decoration: none;
    }
    footer a:hover {
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <canvas id="fireCanvas"></canvas>

  <div class="video-background">
    <iframe
      id="bg-video"
      src="https://www.youtube-nocookie.com/embed/PD8RH_c7Kvk?start=19&autoplay=1&mute=1&controls=0&loop=1&playlist=PD8RH_c7Kvk&enablejsapi=1&iv_load_policy=3&modestbranding=1&fs=0"
      allow="autoplay; encrypted-media;"
      allowfullscreen {/* Może nie być konieczne, jeśli controls=0 i fs=0 */}
    ></iframe>
  </div>

  <div id="click-overlay"></div>

  <nav>
    <a href="index.html" class="nav-logo">DragonConfigs</a>
    <ul class="nav-list">
      <li class="active"><a href="index.html">Strona Główna</a></li>
      <li><a href="Configi.html">Wszystko MC</a></li>
      <li class="dropdown">
        <a href="#">Więcej</a>
        <ul class="dropdown-menu">
          <li><a href="faq.html">FAQ</a></li>
          <li><a href="about.html">O nas</a></li>
        </ul>
      </li>
      <li><a href="download.html">Pobierz</a></li>
      <li><a href="https://discord.gg/pTXQpWgfaE" target="_blank">Kontakt</a></li>
    </ul>
  </nav>

  <header class="hero">
    <div class="typewriter-container">
      <span id="typed-text"></span><span id="cursor">|</span>
    </div>
    <p>Twoje centrum cheatów i configów do Minecrafta</p>
    <a href="Configi.html" class="btn">Zobacz Configi</a>
  </header>

  <footer>
    <p>© 2025 DragonConfigs | Made by XxvoltikxX</p>
    <p><a href="https://minecraft.net" target="_blank" rel="noopener">Oficjalna strona Minecraft</a></p>
  </footer>

  <script src="https://www.youtube.com/iframe_api"></script>

  <script>
    let player;
    let clickOverlayElement; // Zdefiniujmy, aby mieć dostęp później

    // Ta funkcja jest wywoływana przez API YouTube po jego załadowaniu
    function onYouTubeIframeAPIReady() {
      console.log("YouTube IFrame API Ready. Initializing player...");
      player = new YT.Player('bg-video', {
        events: {
          'onReady': onPlayerReady,
          'onStateChange': onPlayerStateChange
        }
      });
    }

    function onPlayerReady(event) {
      // Wideo jest gotowe i powinno automatycznie odtwarzać się wyciszone dzięki parametrom URL.
      console.log("YouTube Player Ready. Video should be autoplaying (muted).");
      // event.target.playVideo(); // Niepotrzebne, jeśli używasz autoplay=1 w URL
      // event.target.mute();    // Niepotrzebne, jeśli używasz mute=1 w URL
    }

    function onPlayerStateChange(event) {
      // Pętla wideo. Parametry URL `loop=1&playlist=VIDEO_ID` powinny to obsłużyć,
      // ale to jest zapasowe rozwiązanie w JS.
      if (event.data === YT.PlayerState.ENDED) {
        player.seekTo(19); // Przewija do Twojego czasu startowego (19 sekund)
        player.playVideo();
        console.log("Video ended and restarted (looping).");
      }
    }

    // Nasłuchiwacz kliknięcia powinien być dodany po załadowaniu DOM.
    document.addEventListener('DOMContentLoaded', () => {
      clickOverlayElement = document.getElementById('click-overlay');

      if (clickOverlayElement) {
        clickOverlayElement.addEventListener('click', () => {
          if (player && typeof player.unMute === 'function' && typeof player.playVideo === 'function') {
            if (player.isMuted()) { // Odcisz tylko, jeśli jest aktualnie wyciszone
                player.unMute();
                console.log("Video unmuted by user click.");
            }
            player.playVideo(); // Upewnij się, że gra
            console.log("Play video command sent after click.");

            // Usuń overlay po pierwszym kliknięciu, aby nie przeszkadzał dalej
            if (clickOverlayElement && clickOverlayElement.parentNode) {
              clickOverlayElement.parentNode.removeChild(clickOverlayElement);
              clickOverlayElement = null; // Wyczyść referencję
              console.log("Click overlay removed.");
            }
          } else {
            console.log("Player not ready or unMute/playVideo function not available yet. User clicked too early or API issue.");
            // Może się zdarzyć, jeśli użytkownik kliknie, zanim API YouTube będzie w pełni gotowe.
          }
        });
      } else {
        console.error("Click overlay element (#click-overlay) not found!");
      }

      // ================================
      // 1) Unoszące się pyłki (Floating Dust)
      // ================================
      (function() {
        const canvas = document.getElementById('fireCanvas');
        if (!canvas) {
            console.warn("Canvas element #fireCanvas not found for particles.");
            return;
        }
        const ctx = canvas.getContext('2d');
        let particles = [];
        const MAX_PARTICLES = 120; // Zmniejszono dla testu, możesz zwiększyć

        function resizeCanvas() {
          canvas.width = window.innerWidth;
          const navHeight = document.querySelector('nav')?.offsetHeight || 60;
          canvas.height = window.innerHeight - navHeight;
          // Po zmianie rozmiaru canvasa, zresetuj pozycje pyłków, aby uniknąć pustych obszarów
          // initParticles(); // Opcjonalnie: jeśli chcesz, aby pyłki "odświeżyły się" przy resize
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas(); // Ustaw rozmiar początkowy

        function randBetween(min, max) {
          return Math.random() * (max - min) + min;
        }

        class Particle {
          constructor() {
            this.reset();
          }
          update() {
            this.y += this.velocityY;
            this.x += this.velocityX;
            this.alpha -= this.decay;

            if (this.alpha <= 0 || this.y < -this.size || this.x < -this.size || this.x > canvas.width + this.size) {
              this.reset(); // Resetuj, gdy zniknie lub wyjdzie poza obszar
            }
          }
          draw() {
            if (this.alpha <= 0) return; // Nie rysuj niewidocznych
            ctx.beginPath();
            ctx.fillStyle = this.color.replace(/[\d\.]+\)$/g, `${this.alpha.toFixed(2)})`); // Poprawione dla alpha
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.closePath();
          }
          reset() {
            this.x = randBetween(0, canvas.width);
            this.y = randBetween(canvas.height, canvas.height + 50); // Startuj z dołu
            this.velocityY = randBetween(-0.3, -1.0); // Ruch w górę
            this.velocityX = randBetween(-0.2, 0.2); // Lekki ruch na boki
            this.size = randBetween(1, 3);
            this.alpha = randBetween(0.2, 0.6); // Trochę bardziej widoczne
            this.decay = randBetween(0.0005, 0.0015);
            const v = Math.floor(randBetween(200, 255));
            this.color = `rgba(${v}, ${v}, ${v}, ${this.alpha})`; // Zapisz początkowy kolor z alpha
          }
        }

        function initParticles() {
          particles = [];
          for (let i = 0; i < MAX_PARTICLES; i++) {
            particles.push(new Particle());
          }
        }
        initParticles();

        let lastTime = 0;
        function animateParticles(timestamp) {
          const deltaTime = timestamp - lastTime;
          lastTime = timestamp;

          // Ogranicz aktualizacje, jeśli deltaTime jest zbyt duże (np. po przełączeniu karty)
          if (deltaTime < 100) { // np. nie aktualizuj, jeśli klatka trwała dłużej niż 100ms
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            particles.forEach(p => {
              p.update(); // Przekaż deltaTime, jeśli animacja ma być zależna od czasu
              p.draw();
            });
          }
          requestAnimationFrame(animateParticles);
        }
        requestAnimationFrame(animateParticles); // Rozpocznij animację
      })();

      // ================================
      // 2) Typing Effect (maszynopis) dla nagłówka
      // ================================
      const typedTextSpan = document.getElementById('typed-text');
      const cursorSpan = document.getElementById('cursor');

      if (typedTextSpan && cursorSpan) {
        const textToType = 'Witaj na stronie DragonConfigs';
        const typingSpeed = 120;
        const erasingSpeed = 60;
        const newTextDelay = 1500;
        let charIndex = 0;
        let isErasing = false;

        function type() {
          if (!typedTextSpan || !cursorSpan) return; // Dodatkowe zabezpieczenie

          if (!isErasing) {
            if (charIndex < textToType.length) {
              typedTextSpan.textContent += textToType.charAt(charIndex);
              charIndex++;
              setTimeout(type, typingSpeed);
            } else {
              setTimeout(() => {
                isErasing = true;
                setTimeout(type, erasingSpeed); // Zacznij kasować po pauzie
              }, newTextDelay);
            }
          } else {
            if (charIndex > 0) {
              typedTextSpan.textContent = textToType.substring(0, charIndex - 1);
              charIndex--;
              setTimeout(type, erasingSpeed);
            } else {
              isErasing = false;
              // Opcjonalnie: zmień tekst do wpisania lub dodaj dłuższą pauzę
              setTimeout(type, typingSpeed); // Zacznij pisać ponownie
            }
          }
        }
        setTimeout(type, newTextDelay); // Początkowe opóźnienie przed rozpoczęciem pisania
      } else {
        console.warn("Elementy #typed-text lub #cursor nie znalezione dla efektu maszynopisu.");
      }
    });
  </script>
</body>
</html>
